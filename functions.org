#+title: Project Functions
#+startup: indent overview hideblocks entitiespretty
#+PROPERTY: header-args:R :session *R* :noeval :noweb yes :comments noweb :mkdirp yes

* Functions:
** Processing the WAV files:
*** Remove NAs from each Waveform:
For reasons unkonwn, the .wav files sometimes contain NA values...  These needed to be removed...

#+name: wav_remove_NAs
#+begin_src R
wav_remove_NAs <- function(waveform) {
  waveform@left[!is.finite(waveform@left)] <- 0
  return(waveform)
}
#+end_src

*** Clean and return normalized WAV
Because of how soundcards work, the audio read into R is - by default - straight raw info... It's essentially a SINE wave raised above the Y-axis...
This stinks and isn't what I wanted to work with. Consequently, I had to work quite a bit with the library to clean each WAV file so it's a normalized [-1,+1] waveform.
This should make the output sounds consistent when they get read later for object-based image analysis. However, the WAV files will have to be converted back to soundcard-friendly files
if they will be replayed.

#+name: read_wav
#+begin_src R
read_wav <- function(file) {
  raw_wav <- tuneR::readWave(file)

  # Remove NA values:
  wav_remove_NAs(raw_wav) -> waveform_no_nas

  # Normalize and center the WAV
  wav_clean<- tuneR::normalize(waveform_no_nas, pcm = FALSE, unit = "1", center = TRUE)

  # Return to caller...
  return(wav_clean)

}
#+end_src

** WAV file metrics:
*** RMS amplitude / roughness calculations

TODO: This should be refactored into fetch metadatas.

#+name: rms_amplitudes
#+begin_src R
rms_amplitudes <- function(files) {
  # vector to hold the mean amplitudes
  rms_amps <- c()

  # Loop over the files and find the amplitudes
  for (file in files){
    # Normalize...
    tuneR::readWave(file) -> waveform
    wav_remove_NAs(waveform) -> waveform
    waveform_n <- tuneR::normalize(waveform, pcm = FALSE, unit = "1", center = TRUE)

    # Calculate the mean amplitude
    rms_amps <- append(rms_amps, rms(waveform_n@left))
  }
  return(rms_amps)
}
#+end_src

*** Fetch metadata for a single audio file:
#+name: wav_metadata
#+begin_src R
# Parameters: _CLEANED_ tuneR::wave class
# Output: vec of metadata
wav_metadata <- function (wav_clean) {
  metadata <- c(samples = length(wav_clean),
                duration = round((length(wav_clean) / wav_clean@samp.rate),3),
                minAmp = min(wav_clean@left),
                medAmp = median(wav_clean@left),
                maxAmp = max(wav_clean@left),
                zcr = seewave::zcr(wav_clean, channel = 1, wl = NULL), # Compute for whole file...
                sampleRate = wav_clean@samp.rate,
                stereo = wav_clean@stereo,
                pcm = wav_clean@pcm,
                bitdepth = wav_clean@bit)

  return(metadata)
}
#+end_src

*** Mutli-Fetch all audio metadata (files):
#+name: wav_metadata_multi
#+begin_src R
<<wav_metadata>>

# Parameters: vec of files
# Output: data.frame of metadata for files
wav_metadata_multi <- function (files) {
  filename <- character() # Empty lists to hold values:
  samples <- numeric()
  duration <- numeric()
  minAmp <- numeric()
  medAmp <- numeric()
  maxAmp <- numeric()
  zcr <- numeric()
  sampleRate <- numeric()
  stereo <- logical()
  pcm <- logical()
  bitdepth <- numeric()

  for(file in files) {

    # Read the raw WAV file...
    raw_wav <- read_wav(file)

    # Pass the CLEANED wave to the metadata fetching function
    metadata <- wav_metadata(raw_wav)

    filename <- append(filename, as.character(file))
    samples <- append(samples, as.numeric(metadata["samples"]))
    duration <- append(duration, as.numeric(metadata["duration"]))
    minAmp <- append(minAmp, as.numeric(metadata['minAmp']))
    medAmp <- append(medAmp, as.numeric(metadata['medAmp']))
    maxAmp <- append(maxAmp, as.numeric(metadata['maxAmp']))
    zcr <- append(zcr, metadata['zcr'])
    sampleRate <- append(sampleRate, as.numeric(metadata["sampleRate"]))
    stereo <- append(stereo, as.logical(metadata["stereo"]))
    pcm <- append(pcm, as.logical(metadata["pcm"]))
    bitdepth <- append(bitdepth, as.numeric(metadata["bitdepth"]))
  }

  # Return the dataframe:
  data.frame(filename, samples, duration,
             minAmp, medAmp, maxAmp, zcr,
             sampleRate, stereo, pcm, bitdepth)
}
#+end_src

** Plotting and Visualization:
*** Plot Waveforms using tuneR package:
#+name: plot_waveform
#+begin_src R
# Parameters:
#   Vector of audio files (char)
#   output directory (char)
#   xlim values
#   bg - background options for png (white by default)
# Outputs to output_dir/x.png
plot_waveforms <- function(files, output_dir, bg = "white") {
  for (file in files) {
    name <- tools::file_path_sans_ext(basename(file))
    output_name <- paste0(output_dir, "/", name, ".png")

    # Fetch clean WAV from supporting function
    wav_clean <- read_wav(file)

    # Calculate xlims and plot_dims
    ppi <- 200
    xlim <- c(0, ceiling(length(wav_clean) / wav_clean@samp.rate))
    plot_dims <- c(xlim[2], 2) * ppi

    # Set up a PNG for output:
    png(filename = output_name, width = plot_dims[1] , height = plot_dims[2], units = "px", bg = bg)

    # Reduce padding x-axis:
    par(xaxs = "i")

    # Plot:
    tuneR::plot(wav_clean, main = name, xlim = xlim,
                xlab = "Time (s)", ylab = "Normalized Amplitude",
                col = "steelblue", lwd = 1.2)

    # Add minor ticks every 0.25 seconds
    tick_spacing <- 0.25
    axis(side = 1, at = seq(0, xlim[2], by = tick_spacing), labels = FALSE, tcl = -0.2)

    dev.off()
  }
}
#+end_src

*** Plot Spectrogram using Seewave
#+name: plot_spectrogram
#+begin_src R
plot_spectrogram <- function(file, output_dir, bg = 'white') {
  # Spectrogram
  # Read file, parse filename
  name <- tools::file_path_sans_ext(basename(file))
  spectrogram_name <- paste0('Spectrogram of ', name)
  output_name <- paste0(output_dir, '/', name, '.png')

  waveform <- readWave(file) # We need the non-normalized .wav file this time...

  # Remove NAs:
  waveform@left[!is.finite(waveform@left)] <- 0

  # Plot for a duration:
  duration <- 3 # seconds of data:
  # Duration to samples
  samples = duration * waveform@samp.rate # Samples = duration * samples/sec
  sample_range <- c(initial = 0,
                    final = samples) # initial to final...

  png(filename = output_name, bg = bg)

  seewave::spectro(waveform[sample_range['initial']:sample_range['final']],
                   flim = c(0.3, 0.9),
                   main = spectrogram_name)
  dev.off()
}
#+end_src



* Main File:
Assemble/Tangle the main ~functions.R~ file:
#+begin_src R :tangle R/project_functions.R
library(tuneR)
library(seewave)

<<wav_remove_NAs>>
<<read_wav>>

<<wav_metadata_multi>>

<<rms_amplitudes>>

<<plot_waveform>>

<<plot_spectrogram>>
#+end_src
