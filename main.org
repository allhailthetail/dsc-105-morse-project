#+title: Main File - Morse Project
#+startup: indent hideblocks entitiespretty
#+PROPERTY: header-args:R :session *R* :results output :mkdirp yes

* Prerequisites
- [[file:functions.org][Supporting Functions]]

- Org tweaks:
  #+begin_src elisp
  (org-display-inline-images t)
  (+org-pretty-mode t)
  #+end_src

  #+RESULTS:
  : t

- Create directories for Plots, etc:
  #+begin_src bash :results silent
  mkdir -p plots/general               # to store plots...
  mkdir -p plots/waveforms/initial     # to store initial waveforms
  mkdir -p plots/waveforms/denoised    # to store denoised waveforms
  mkdir -p plots/spectrograms/initial  # to store initial spectrograms
  mkdir -p plots/spectrograms/denoised # to store initial spectrograms
  mkdir -p R                           # to store tangled functions:
  mkdir -p csv/                        # to store generated CSVs.
  mkdir -p out/                        # to store generated wavs
  #+end_src

- *Configure the working directory:*
  #+begin_quote
  The project is assuming that R's working directory is the repository root. For simplicity, I set this up
  as an environment variable on my system, ~MORSE_ROOT~ and pointed R that as shown...
  #+end_quote

- Init R and set working dir:
  #+begin_src R :results silent
  # Get and set the working directory:
  Sys.getenv("MORSE_ROOT") -> projectRoot
  setwd(projectRoot)
  getwd()
  #+end_src

- Tangle functions in =functions.org=
  #+begin_src emacs-lisp
  (org-babel-tangle-file "functions.org")
  #+end_src

  #+RESULTS:
  | /home/matthew/playground/morse-project/R/project_functions.R |

- The following dependencies need to be installed so that the audio processing can take place:
  #+name: imports
  #+begin_src R :results silent
  library(tidyverse)
  library(ggplot2)
  library(sonicscrewdriver)
  library(tuneR)
  source("R/project_functions.R")
  #+end_src

* Step 1: Exploratory Data Analysis:
** File Operations with R:
#+begin_src R
"data" -> audio_files_path
list.files(audio_files_path,
           full.names=TRUE) -> audio_files # this is a vec of all our audio files

length(audio_files) # number of files to analyze...
#+end_src

#+RESULTS:
: [1] 200

** Gathering basic metadata:
#+name: gather_basic_metadata
#+begin_src R
# Fetch metadata for the dir of files:
basic_metadata <- wav_metadata_multi(audio_files)

# Summary of metadata gathered...
summary(basic_metadata)

# Show first few entries...
head(basic_metadata, 2)

# Audio duration sum()/60s/min
#total_duration_mins <- sum(basic_metadata$duration)/60
#paste('Total duration:', total_duration_mins)

#+end_src

#+RESULTS: gather_basic_metadata
#+begin_example
filename            samples          duration          minAmp            medAmp               maxAmp            zcr           sampleRate
 Length:200         Min.   : 37327   Min.   : 4.666   Min.   :-1.0000   Min.   :-0.0034242   Min.   :0.9939   Min.   :0.3034   Min.   :8000
 Class :character   1st Qu.: 53932   1st Qu.: 6.742   1st Qu.:-0.9925   1st Qu.:-0.0008947   1st Qu.:1.0000   1st Qu.:0.3233   1st Qu.:8000
 Mode  :character   Median : 73026   Median : 9.129   Median :-0.9814   Median :-0.0002655   Median :1.0000   Median :0.3470   Median :8000
                    Mean   : 86519   Mean   :10.815   Mean   :-0.9669   Mean   :-0.0003932   Mean   :0.9998   Mean   :0.3787   Mean   :8000
                    3rd Qu.:105775   3rd Qu.:13.222   3rd Qu.:-0.9521   3rd Qu.: 0.0001726   3rd Qu.:1.0000   3rd Qu.:0.4418   3rd Qu.:8000
                    Max.   :216967   Max.   :27.121   Max.   :-0.8366   Max.   : 0.0016475   Max.   :1.0000   Max.   :0.4887   Max.   :8000
   stereo           pcm             bitdepth
 Mode :logical   Mode :logical   Min.   :32
 FALSE:200       FALSE:200       1st Qu.:32
                                 Median :32
                                 Mean   :32
                                 3rd Qu.:32
                                 Max.   :32
filename samples duration     minAmp        medAmp maxAmp       zcr sampleRate stereo   pcm bitdepth
1 data/cw001.wav  139046   17.381 -0.9847528 -0.0005326462      1 0.4782230       8000  FALSE FALSE       32
2 data/cw002.wav   92953   11.619 -0.9619644 -0.0009481643      1 0.3220552       8000  FALSE FALSE       32
#+end_example

#+RESULTS:
#+begin_example
filename            samples          duration        sampleRate     stereo          pcm             bitdepth
 Length:200         Min.   : 37327   Min.   : 4.666   Min.   :8000   Mode :logical   Mode:logical   Min.   :8
 Class :character   1st Qu.: 53932   1st Qu.: 6.742   1st Qu.:8000   FALSE:200       TRUE:200       1st Qu.:8
 Mode  :character   Median : 73026   Median : 9.129   Median :8000                                  Median :8
                    Mean   : 86519   Mean   :10.815   Mean   :8000                                  Mean   :8
                    3rd Qu.:105775   3rd Qu.:13.222   3rd Qu.:8000                                  3rd Qu.:8
                    Max.   :216967   Max.   :27.121   Max.   :8000                                  Max.   :8
filename samples duration sampleRate stereo  pcm bitdepth
1 data/cw001.wav  139046   17.381       8000  FALSE TRUE        8
2 data/cw002.wav   92953   11.619       8000  FALSE TRUE        8
[1] "Total duration: 36.0497166666667"
#+end_example

#+begin_quote
- So, there's not a lot to see, but already we can draw some conclusions:
  1. We're dealing with approximately 36 minutes worth of data in total.
  2. All of it is mono audio, so we don't need to average the two channels
  3. There are more samples per file than would be efficient to graph as individual points,
     Luckily, tuneR has a special plot function that handles this...
#+end_quote
** Duration vs Samples
#+begin_src R :file plots/general/samples-v-duration.png :results file graphics
ggplot(basic_metadata, aes(duration, samples)) +
  labs(x = 'Clip Duration (seconds)', y = 'Samples',
       title = "Clip Samples vs Duration") +
       theme(plot.title = element_text(hjust = 0.5)) +
  geom_point()
#+end_src

#+RESULTS:
[[file:plots/general/samples-v-duration.png]]

Note how there's a perfectly linear relationship between duration and sample size.
This should hold for all audio recorded at the same sampling rate.  Neat...

** Filling in Known Predictions:
- Handy Regex: =(\d+),\s*(\w*) -> basic_metadata$prediction[\1] <- "\2"=
    #+names: metadata - add predictions
    #+begin_src R :results silent
    basic_metadata$prediction <- NA

    # Add in the given predictions from the challenge:
    basic_metadata$prediction[5] <- "FEFOFQUHYNZ3WONZRETF"
    basic_metadata$prediction[9] <- "5NITCM6O7M3VYTFUOLGB"
    basic_metadata$prediction[18] <- "NPAIUS139K2A5T2IQZY9"
    basic_metadata$prediction[22] <- "TF5E6V73PCP3C18OQIQ8"
    basic_metadata$prediction[25] <- "YQ4CBEH852FAR5AGTBS2"
    basic_metadata$prediction[26] <- "AVXDKKCKEB1EX8QABF7C"
    basic_metadata$prediction[27] <- "63BTNYH7OJ7XKBNYOV49"
    basic_metadata$prediction[28] <- "LGYI857RG7FXVFVGB7E3"
    basic_metadata$prediction[35] <- "8BKR52AIQ3SPVHAM2T2C"
    basic_metadata$prediction[37] <- "R2DX08BDJE46A0NU6ZT3"
    basic_metadata$prediction[41] <- "N5DAV420EZMYJ86MM2RF"
    basic_metadata$prediction[44] <- "BCYCKRK4YC1ACGOQ1771"
    basic_metadata$prediction[45] <- "89E536S85K7696K4824L"
    basic_metadata$prediction[47] <- "EZRXQHXYJZ4AIZ15AFFM"
    basic_metadata$prediction[49] <- "GWII2VNNDB5U74ZPYUUC"
    basic_metadata$prediction[50] <- "7KYQ1KSW9U7KWW9BW9CD"
    basic_metadata$prediction[53] <- "ET98RNOX26UAX013JLES"
    basic_metadata$prediction[62] <- "YWBRAOI6HLSTYKMIFQ8E"
    basic_metadata$prediction[71] <- "GKYGS8K1MQCHD15NCV9H"
    basic_metadata$prediction[72] <- "SIJP60T90447282IAP0G"
    basic_metadata$prediction[74] <- "K7OOLNPK60WUC5PC6L0X"
    basic_metadata$prediction[76] <- "KWOA6I12TE85P59HY272"
    basic_metadata$prediction[82] <- "B9MBJBCG088X5HEQFYBP"
    basic_metadata$prediction[84] <- "VS7FCHNSK6UBYHBG7Q6A"
    basic_metadata$prediction[90] <- "Y3POCL0TOB48OA23PP4X"
    basic_metadata$prediction[91] <- "TUB8FKBT1F0HDJC4E5JJ"
    basic_metadata$prediction[95] <- "TJ9DYTTIC1IEGOGDGKBG"
    basic_metadata$prediction[96] <- "FWRUHOKDX83UY4CXPGKT"
    basic_metadata$prediction[99] <- "8M9AGRKOW33JY9JC6P9E"
    basic_metadata$prediction[111] <- "EJGRJWSOJBATCY9YF93R"
    basic_metadata$prediction[115] <- "YYSH3K45WAXIY7EZHKIE"
    basic_metadata$prediction[118] <- "AOSXW13N9RQZ7CRZ7MJS"
    basic_metadata$prediction[119] <- "ZDPTZFSGG1ZQEOK4ORRB"
    basic_metadata$prediction[123] <- "OPIB1TZHIT8QNYBZ1P9O"
    basic_metadata$prediction[124] <- "H6I4HVYJH8DFEEPM4PCT"
    basic_metadata$prediction[128] <- "XW8XLJ2K9O5V12LLT4Q9"
    basic_metadata$prediction[129] <- "P299MVR0XGG51UWPSNKR"
    basic_metadata$prediction[130] <- "0JOJRS92O0TPMJQDTNHC"
    basic_metadata$prediction[148] <- "RS00DAAA04UVGG3WALGS"
    basic_metadata$prediction[149] <- "A9N0QQ8IFFZ0Z89LYNFI"
    basic_metadata$prediction[151] <- "K3ZC88XILS6Y9WPJWAUI"
    basic_metadata$prediction[152] <- "WMDQP6JCDDU6U8LEWVZY"
    basic_metadata$prediction[155] <- "6H2NCKWC0HFH00JGYY7R"
    basic_metadata$prediction[157] <- "3XIVCTHI5M7QAWIS7UL0"
    basic_metadata$prediction[158] <- "JO0G95ECU0SBO7N2QOVD"
    basic_metadata$prediction[159] <- "LUS34SYEYV7H1CNKXF8M"
    basic_metadata$prediction[161] <- "7F2PQX5LVC1XV9ZYTRR3"
    basic_metadata$prediction[165] <- "0S8PT84E5DU0ZMX4OD91"
    basic_metadata$prediction[166] <- "216PENQ5527G3YQ4Z4DE"
    basic_metadata$prediction[167] <- "QMWHZO5E67APYHM3JL5M"
    basic_metadata$prediction[171] <- "W10IQ4YD09M01A8WJOHP"
    basic_metadata$prediction[175] <- "03IWB4JYRUE2LBPMN5X1"
    basic_metadata$prediction[176] <- "E8G8V81FIYVERSUPKPJY"
    basic_metadata$prediction[178] <- "1UPUX15HK586V8Q1DK4W"
    basic_metadata$prediction[180] <- "PG8BUHZGV31HO9YMICWC"
    basic_metadata$prediction[188] <- "YQYXB1LM2SNGPBTHHJ1D"
    basic_metadata$prediction[194] <- "FJQSR2P1Y2T2XU5RK63T"
    basic_metadata$prediction[199] <- "ZEA2Y4H4NX6JST0J3IY8"
    #+end_src

** Bulk generate initial waveforms:
[[file:~/playground/morse-project/plots/waveforms/initial/][Output Directory]]
#+begin_src R :results silent
audio_files <- basic_metadata$filename
plot_waveforms(audio_files, "plots/waveforms/initial")
#+end_src

#+begin_quote
Some, like cw002 and cw003 seem to be readable with no adjustments:
CW002: WRBCDGB5T1JNN63C3MR3
CW003: G1FNCKUDZ63TSIJ5QH47
#+end_quote
[[file:plots/waveforms/initial/cw002.png][cw002]]
[[file:plots/waveforms/initial/cw003.png][cw003]]

** Boxplot of the durations:
#+begin_src R :file plots/general/dur-hist.png :results file graphics
summary_duration <- summary(basic_metadata$duration)
mean_text <- paste("Mean:", round(summary_duration["Mean"], 2), "sec")

hist(x = basic_metadata$duration, xlab = "seconds", main = "Audio File Durations in Seconds", col = "lightblue")
abline(v = summary_duration["Mean"], col = "red")
abline(v = summary_duration["1st Qu."], col = "dark grey")
abline(v = summary_duration["3rd Qu."], col = "dark grey")
text(x = 20, y = 40, labels = mean_text, col = "black", cex = 1.5)
#+end_src

#+RESULTS:
[[file:plots/general/dur-hist.png]]

#+begin_quote
Remember, this is a graphical representation of what summary already says:
> summary(basic_metadata$duration)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  4.666   6.742   9.129  10.815  13.222  27.121

So, the files are typically no less than ~6-3/4 seconds in length, no more than ~13-1/4 seconds...
The skew shows that there are outlier files that are particularly long. The original dataset did mention that there was corruption in the initial upload, so that should be investigated.
#+end_quote

** Investigating long files outside Q3:
#+begin_src R
q3 <- 13.222
above_q3 <- basic_metadata$duration > q3

# These are the files that are longer than average...
head(basic_metadata[above_q3,], 5)

# Number of Characters in samples
numChars <- nchar(basic_metadata$prediction[27])
numChars
#+end_src

#+RESULTS:
: filename samples duration     minAmp        medAmp maxAmp       zcr sampleRate stereo   pcm bitdepth           prediction
: 1  data/cw001.wav  139046   17.381 -0.9847528 -5.326462e-04      1 0.4782230       8000  FALSE FALSE       32                 <NA>
: 6  data/cw006.wav  113453   14.182 -0.9739577  6.703265e-04      1 0.4540206       8000  FALSE FALSE       32                 <NA>
: 7  data/cw007.wav  167199   20.900 -0.9541101 -6.145662e-04      1 0.3264553       8000  FALSE FALSE       32                 <NA>
: 12 data/cw012.wav  176165   22.021 -0.8699628 -4.308391e-04      1 0.4597338       8000  FALSE FALSE       32                 <NA>
: 27 data/cw027.wav  162155   20.269 -0.9961065 -3.667245e-05      1 0.3233079       8000  FALSE FALSE       32 63BTNYH7OJ7XKBNYOV49
: [1] 20

#+begin_quote
Actually, I do see a pattern now that the data is visualized and in a table...
Conveniently for us, every message seems to contain 20 characters. That means that we can get a good estimate of
the words per minute for each file with no extra effort!! Perfect for training a model...

WPM = (60s x numChars/5)/time
WPM = 12 x numChars / time
#+end_quote

** Let's add Words Per Minute to the Metadata:
#+begin_src R
approx_wpm <- round((12 * numChars) / basic_metadata$duration, 2)
basic_metadata$approx_wpm <- approx_wpm
head(basic_metadata)
summary(basic_metadata$approx_wpm)
#+end_src

#+RESULTS:
: filename samples duration     minAmp        medAmp maxAmp       zcr sampleRate stereo   pcm bitdepth           prediction approx_wpm
: 1 data/cw001.wav  139046   17.381 -0.9847528 -5.326462e-04      1 0.4782230       8000  FALSE FALSE       32                 <NA>      13.81
: 2 data/cw002.wav   92953   11.619 -0.9619644 -9.481643e-04      1 0.3220552       8000  FALSE FALSE       32                 <NA>      20.66
: 3 data/cw003.wav   47526    5.941 -0.9958870 -2.228767e-03      1 0.3279889       8000  FALSE FALSE       32                 <NA>      40.40
: 4 data/cw004.wav   59983    7.498 -0.9633315 -1.629695e-04      1 0.4852375       8000  FALSE FALSE       32                 <NA>      32.01
: 5 data/cw005.wav   52381    6.548 -0.9701112 -5.018725e-05      1 0.3301006       8000  FALSE FALSE       32 FEFOFQUHYNZ3WONZRETF      36.65
: 6 data/cw006.wav  113453   14.182 -0.9739577  6.703265e-04      1 0.4540206       8000  FALSE FALSE       32                 <NA>      16.92
: Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
:    8.85   18.15   26.29   26.58   35.60   51.44

#+begin_src R :file plots/general/wpm-approx.png :results file graphics
# And, we'll visualize that as well...
bins <- round(1 + log(length(basic_metadata), b = 2))
ggplot(basic_metadata, aes(approx_wpm)) +
  labs(title = 'Estimated WPM values for Audio Clips', x = 'Words per Minute', y = 'Frequency') +
  geom_histogram(fill = 'skyblue', color = 'white', linewidth = 1, binwidth = bins)
#+end_src

#+RESULTS:
[[file:plots/general/wpm-approx.png]]

So, most of our morse code data will be between 18 and 35.6 WPM...

** Export Initial Data to CSV
#+begin_src R :results silent
write.csv(basic_metadata, file = "csv/basic_metadata.csv")
#+end_src

* Step 2: Audio Signal Summaries:
** Copy the dataframe
  #+begin_src R
  detailed_analysis <- basic_metadata
  #+end_src

  #+RESULTS:

** Exploring RMS amplitude / "roughness"
#+begin_src R
rms_amplitudes(basic_metadata$filename) -> detailed_analysis$rms_amplitude
head(detailed_analysis)
#+end_src

#+RESULTS:
#+begin_example
filename samples duration     minAmp        medAmp maxAmp       zcr sampleRate stereo   pcm bitdepth           prediction approx_wpm
1 data/cw001.wav  139046   17.381 -0.9847528 -5.326462e-04      1 0.4782230       8000  FALSE FALSE       32                 <NA>      13.81
2 data/cw002.wav   92953   11.619 -0.9619644 -9.481643e-04      1 0.3220552       8000  FALSE FALSE       32                 <NA>      20.66
3 data/cw003.wav   47526    5.941 -0.9958870 -2.228767e-03      1 0.3279889       8000  FALSE FALSE       32                 <NA>      40.40
4 data/cw004.wav   59983    7.498 -0.9633315 -1.629695e-04      1 0.4852375       8000  FALSE FALSE       32                 <NA>      32.01
5 data/cw005.wav   52381    6.548 -0.9701112 -5.018725e-05      1 0.3301006       8000  FALSE FALSE       32 FEFOFQUHYNZ3WONZRETF      36.65
6 data/cw006.wav  113453   14.182 -0.9739577  6.703265e-04      1 0.4540206       8000  FALSE FALSE       32                 <NA>      16.92
  rms_amplitude
1     0.2412031
2     0.3730158
3     0.4234468
4     0.2417161
5     0.3066560
6     0.2234551
#+end_example

Now, we should be able to see from the rms which are clearer and more noisy files:

#+begin_src R
min(detailed_analysis$rms_amplitude) -> low_rms
max(detailed_analysis$rms_amplitude) -> high_rms

detailed_analysis[detailed_analysis$rms_amplitude == low_rms,]
detailed_analysis[detailed_analysis$rms_amplitude == high_rms,]
#+end_src

#+RESULTS:
: filename samples duration     minAmp       medAmp maxAmp       zcr sampleRate stereo   pcm bitdepth prediction approx_wpm rms_amplitude
: 92 data/cw092.wav   83671   10.459 -0.9122674 0.0001603664      1 0.4779434       8000  FALSE FALSE       32       <NA>      22.95     0.1978287
: filename samples duration minAmp       medAmp    maxAmp       zcr sampleRate stereo   pcm bitdepth           prediction approx_wpm
: 74 data/cw074.wav   81555   10.194     -1 -0.002191738 0.9989054 0.3170866       8000  FALSE FALSE       32 K7OOLNPK60WUC5PC6L0X      23.54
:    rms_amplitude
: 74      0.445678

Sure enough, CW092 looks quite terrible, whereas CW074 is quite clear. This is probably what we're looking to optimize...

[[file:~/playground/morse-project/plots/waveforms/initial/cw092.png][Graphic - cw092]]
[[file:~/playground/morse-project/plots/waveforms/initial/cw074.png][Graphic - cw074]]

** Zero-crossing rate / measure of noise
#+begin_src R :results graphics file :file plots/general/zcr-vs-rms-amp.png
plot(detailed_analysis$zcr ~ detailed_analysis$rms_amplitude,
     main = 'Zero-crossing rate compared with root-mean-square amplitude:',
     xlab = 'RMS amplitude', ylab = 'zero-crossing rate')

ggplot(detailed_analysis, aes(zcr, rms_amplitude)) +
  labs(title = 'RMS Amplitude vs Zero-crossing Rate', x = 'ZCR', y = 'RMS Amplitude') +
  geom_point(color = 'skyblue')
#+end_src

#+RESULTS:
[[file:plots/general/zcr-vs-rms-amp.png]]

o[[file:plots/general/zcr-vs-rms-amp.png]]

#+begin_quote
"The RMS energy provides a representation of the overall intensity or strength of a sound signal by taking into account both positive and negative excursions of the waveform, providing a more accurate measure of the signal's power..."

"A higher zero crossing rate shows that the signal changes its direction frequently, suggesting the presence of higher-frequency components or a more dynamic waveform. Conversely, a lower zero crossing rate indicates a relatively smoother or constant waveform."
  - [[https://towardsdatascience.com/decoding-the-symphony-of-sound-audio-signal-processing-for-musical-engineering-c66f09a4d0f5/][Towards Data Science]]


This makes sense...
#+end_quote

#+name: ZCR of a clean file:
#+begin_src R :results file graphics :file plots/general/zcr-initial-074.png
cw074 <- read_wav('data/cw074.wav')
zcr_cw074 <- zcr(cw074)[1:150,]
plot(zcr_cw074, main = 'Zero-crossing-rate for cw074.wav', type = 'l', col = 'green')
#+end_src

#+RESULTS: ZCR of a clean file:
[[file:plots/general/zcr-initial-074.png]]

#+name: ZCR of a noisy file:
#+begin_src R :results file graphics :file plots/general/zcr-initial-092.png
cw092 <- read_wav('data/cw092.wav')
zcr_cw092 <- zcr(cw092)[1:150,]
plot(zcr_cw092, main = 'Zero-crossing rate for cw092.wav', type = 'l', col = 'red')
#+end_src

#+RESULTS: ZCR of a noisy file:
[[file:plots/general/zcr-initial-092.png]]

#+name: ZCR Comparison:
#+begin_src R :results file graphics :file plots/general/zcr_i_092_vs_074.png
min_length <- min(length(zcr_cw092), length(zcr_cw074))

z92 <- zcr_cw092[1:min_length]
z74 <- zcr_cw074[1:min_length]

x_values <- seq(1, min_length)

plot(zcr_cw092, ylim = c(0.1, 0.6), type = 'l', col = 'red',
     main = 'comparison of ZCR over time for two waveforms:')
lines(zcr_cw074, type = 'l', col = 'green')
legend('bottomright', legend = c('cw092', 'cw074'), col = c('red', 'green'), lty = 1)
#+end_src

#+RESULTS: ZCR Comparison:
[[file:plots/general/zcr_i_092_vs_074.png]]

=Basically, higher ZCR -> higher static...=
Lower RMS, lower noise.
#+begin_example R
subset(detailed_analysis, detailed_analysis$rms > 0.3448)$filename # Are all exceptionally clean files...
subset(detailed_analysis, detailed_analysis$rms >= 0.29 & detailed_analysis$rms < 0.3)$filename # These are your average recordings...
#+end_example

* Step 3: - Cleaning up the Audio With Seewave
** Selecting the worst of the worst also having predictors:
But, I want a dirty file which I've been given a prediction for...
Tidyverse to the rescue...

#+begin_src R
detailed_analysis %>% filter(rms_amplitude < .22, prediction != "") %>%
  select(filename, duration, zcr, prediction, rms_amplitude) -> noisy_with_prediction

noisy_with_prediction
#+end_src

#+RESULTS:
: filename duration       zcr           prediction rms_amplitude
: 1 data/cw047.wav   24.473 0.4078372 EZRXQHXYJZ4AIZ15AFFM     0.1984195
: 2 data/cw099.wav   24.261 0.4682134 8M9AGRKOW33JY9JC6P9E     0.2161841
: 3 data/cw149.wav    8.826 0.4316003 A9N0QQ8IFFZ0Z89LYNFI     0.2180369

#+attr_html: :width 50% :align right
[[file:plots/waveforms/initial/cw047.png][cw047 Waveform]]

#+attr_html: :width 50% :align right
[[file:plots/waveforms/initial/cw099.png][cw099 Waveform]]

#+attr_html: :width 50% :align right
[[file:plots/waveforms/initial/cw149.png][cw149 Waveform]]

Any of these look like excellent candidates!

** Applying spline denoising - Seewave:

#+begin_src R :results silent
# Denoise cw047:
file <- 'data/cw047.wav'
out_file <- 'out/cw047_denoised_spline.wav'

denoised_wave <- file %>%
  tuneR::readWave() %>%
  wav_remove_NAs() %>%
  seewave::rmnoise(output = "Wave") %>%
  tuneR::normalize(unit = "32")

tuneR::writeWave(denoised_wave, out_file)

file <- 'data/cw099.wav'
out_file <- 'out/cw099_denoised_spline.wav'

# Denoise cw149:
denoised_wave <- file %>%
  tuneR::readWave() %>%
  wav_remove_NAs() %>%
  seewave::rmnoise(output = "Wave") %>%
  tuneR::normalize(unit = "32")

tuneR::writeWave(denoised_wave, out_file)

file <- 'data/cw149.wav'
out_file <- 'out/cw149_denoised_spline.wav'

denoised_wave <- file %>%
  tuneR::readWave() %>%
  wav_remove_NAs() %>%
  seewave::rmnoise(output = "Wave") %>%
  tuneR::normalize(unit = "32")

tuneR::writeWave(denoised_wave, out_file)
#+end_src

*** Comparing the spectrograms:

#+begin_src R :results silent
# Spectrogram
# Read file, parse filename
file <- './data/cw047.wav'
out_dir <- 'plots/spectrograms/initial'
plot_spectrogram(file, out_dir)

#Denoised version
file <- './out/cw047_denoised_spline.wav'
out_dir <- 'plots/spectrograms/denoised'
plot_spectrogram(file, out_dir)
#+end_src

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/initial/cw047.png][Initial Spectrogram - cw047]]

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/denoised/cw047_denoised_spline.png][Denoised Spectrogram - cw047]]

#+begin_src R :results silent
# Spectrogram
# Read file, parse filename
file <- './data/cw099.wav'
out_dir <- 'plots/spectrograms/initial'
plot_spectrogram(file, out_dir)

#Denoised version
file <- './out/cw099_denoised_spline.wav'
out_dir <- 'plots/spectrograms/denoised'
plot_spectrogram(file, out_dir)
#+end_src

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/initial/cw099.png][Initial Spectrogram - cw099]]

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/denoised/cw099_denoised_spline.png][Denoised Spectrogram - cw099]]


#+begin_src R :results silent
# Spectrogram
# Read file, parse filename
file <- './data/cw149.wav'
out_dir <- 'plots/spectrograms/initial'
plot_spectrogram(file, out_dir)

#Denoised version
file <- './out/cw149_denoised_spline.wav'
out_dir <- 'plots/spectrograms/denoised'
plot_spectrogram(file, out_dir)
#+end_src

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/initial/cw149.png][Initial Spectrogram - cw149]]

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/denoised/cw149_denoised_spline.png][Denoised Spectrogram - cw149]]

#+begin_quote
This gave some interesting results:
Giving these files a listen, it's obvious the high-frequency components were removed (as the spectrograms show).
However, there's still a lot of low-frequency background noise still present.

Seewave's [[https://cran.r-project.org/web/packages/seewave/refman/seewave.html#rmnoise][docs]] specifically note that this particular function - by itself - isn't great for removing noise at
frequencies below the target:

"Low frequency noise might not be removed out properly."
#+end_quote

** Applying a Butterworth filter - Seewave:

#+begin_src R :results silent
# Denoise cw047:
file <- 'data/cw047.wav'
out_file <- 'out/cw047_denoised_bworth.wav'

bw <- 70
center <- 610
f_range <- c(center - bw/2, center + bw/2)

denoised_wave <- file %>%
  tuneR::readWave() %>%
  wav_remove_NAs() %>%
  bwfilter(from = f_range[1], to = f_range[2], output = "Wave") %>%
  tuneR::normalize(unit = "32")

tuneR::writeWave(denoised_wave, out_file)

file <- 'data/cw099.wav'
out_file <- 'out/cw099_denoised_bworth.wav'

# Denoise cw149:
denoised_wave <- file %>%
  tuneR::readWave() %>%
  wav_remove_NAs() %>%
  bwfilter(from = f_range[1], to = f_range[2], output = "Wave") %>%
  tuneR::normalize(unit = "32")

tuneR::writeWave(denoised_wave, out_file)

file <- 'data/cw149.wav'
out_file <- 'out/cw149_denoised_bworth.wav'

denoised_wave <- file %>%
  tuneR::readWave() %>%
  wav_remove_NAs() %>%
  bwfilter(from = f_range[1], to = f_range[2], output = "Wave") %>%
  tuneR::normalize(unit = "32")

tuneR::writeWave(denoised_wave, out_file)
#+end_src

*** Comparing the spectrograms:

#+begin_src R :results silent
# Spectrogram
# Read file, parse filename
file <- './data/cw047.wav'
out_dir <- 'plots/spectrograms/initial'
plot_spectrogram(file, out_dir)

#Denoised version
file <- './out/cw047_denoised_bworth.wav'
out_dir <- 'plots/spectrograms/denoised'
plot_spectrogram(file, out_dir)
#+end_src

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/initial/cw047.png][Initial Spectrogram - cw047]]

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/denoised/cw047_denoised_bworth.png][Denoised Spectrogram - cw047]]

#+begin_src R :results silent
# Spectrogram
# Read file, parse filename
file <- './data/cw099.wav'
out_dir <- 'plots/spectrograms/initial'
plot_spectrogram(file, out_dir)

#Denoised version
file <- './out/cw099_denoised_bworth.wav'
out_dir <- 'plots/spectrograms/denoised'
plot_spectrogram(file, out_dir)
#+end_src

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/initial/cw099.png][Initial Spectrogram - cw099]]

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/denoised/cw099_denoised_bworth.png][Denoised Spectrogram - cw099]]

#+begin_src R :results silent
# Spectrogram
# Read file, parse filename
file <- './data/cw149.wav'
out_dir <- 'plots/spectrograms/initial'
plot_spectrogram(file, out_dir)

#Denoised version
file <- './out/cw149_denoised_bworth.wav'
out_dir <- 'plots/spectrograms/denoised'
plot_spectrogram(file, out_dir)
#+end_src

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/initial/cw149.png][Initial Spectrogram - cw149]]

#+attr_html: :width 50% :align right
[[file:plots/spectrograms/denoised/cw149_denoised_bworth.png][Denoised Spectrogram - cw149]]

#+begin_quote
This gave some interesting results:
Giving these files a listen, it's obvious the high-frequency components were removed (as the spectrograms show).
However, there's still a lot of low-frequency background noise still present.

Seewave's [[https://cran.r-project.org/web/packages/seewave/refman/seewave.html#rmnoise][docs]] specifically note that this particular function - by itself - isn't great for removing noise at
frequencies below the target:

"Low frequency noise might not be removed out properly."
#+end_quote

* Pre-commit Clean-up:
  #+name:Remove Generated Files
  #+begin_src bash :results silent :noeval
  rm -r plots  # Remove plots dir...
  rm -r csv    # Remove csv data
  rm -r R      # Dir of supporting functions
  rm -r .Rhistory # R history file
  #+end_src

 Clean up Babel output blocks:
 #+begin_example elisp
 (+org/remove-result-blocks)
 #+end_example
