#+TITLE: Morse Project Presentation Prep
#+AUTHOR: Matthew Younger
#+DATE: 2025-11-18

#+STARTUP: indent overview hideblocks entitiespretty
#+PROPERTY: header-args:elisp :results output
#+PROPERTY: header-args:R :session *R* :results output
#+PROPERTY: header-args:sh :results silent

:ELISP-HELPERS:
Org Customizations
#+name: Emacs tweaks
#+begin_src elisp
(+org-pretty-mode t)
(flyspell-mode 0)
(org-mode-restart) ;; Ensures the headers get read if created from template.
#+end_src

Tangle =functions.org= for use in this project, also:
#+name: tangle functions.org
#+begin_src elisp
(org-babel-tangle-file "../functions.org" "./presentation/R/project_functions.R")
#+end_src

These will be used to permanently hold the illustrations for the presentation.
#+name: Create plots directories
#+begin_src bash
mkdir -p ./img
#+end_src

Adjusted to the subdir for the presentation:
#+name: initialize R
#+begin_src R
# Get and set the working directory:
paste0(Sys.getenv("MORSE_ROOT"), "presentation/") -> projectRoot
setwd(projectRoot)
#+end_src

#+name: import dependencies
#+begin_src R
source("R/project_functions.R")
library(tidyverse)
library(seewave)
library(tuneR)
library(ggplot2)
#+end_src

Project Cleanup
#+name: Project Cleanup Interactive
#+begin_src elisp :results silent
(defun +temp/cleanup-this-project ()
  "Cleans up trivial/generated project files"
  (interactive) ;; make this available with M-x
  (+org/remove-result-blocks 0) ;; remove result blocks back to the beginning...
  ;;(delete-directory project-dir t) ;; delete src directory
  (delete-directory "R" t) ;; Delete R functions derived from one dir up.
  (delete-directory "img" t)) ;; Delete the img folder
  #+end_src

Tangle all files automatically
#+name: Tangle All Blocks
#+begin_src elisp
;; It's nice if when calling org-babel-execute-buffer, that includes tangling all my files...
(org-babel-tangle) ;; tangle everything as a last step...
#+end_src

:END:

* EDA - Characterizing the Data
** Checking for corruption:
#+attr_html: :width 50% :align left
[[file:~/playground/morse-project/plots/general/samples-v-duration.png][Samples versus Duration]]

#+begin_quote
There was some question of corruption in the data, per the poster of the dataset. I thought this was a clever way to speculate that the majority of the data was in the file...

Since the sample rate for each file was fixed at 8000 samples/second, we expect a linear relationship between samples and duration, which it is...
#+end_quote

** The coding rate:
#+attr_html: :width 50% :align left
[[file:~/playground/morse-project/plots/general/density-wpm.png][Words per Minute Density plot]]

#+begin_quote
This was an important graphic. For one, WPM wasn't provided, it was actually derived from the data, noticing that each file contained the same number of characters, and the length of the file was known...

From this information, it can be seen that there is a bimodal distribution, and there's a bit of a hump on the lower end...  So, there are many samples near the median (28), which is a typical speed, but clustered in two groups, on the slower side and on the faster side. We also got a few samples at a very rapid speed of ~50WPM, which is on the edge of intelligibility for most people.

All without actually listening to a single file...
#+end_quote

** Edge Cases
As guest lecturer Brandon Smith emphasized, edge cases are important. Where are they?

*** [[file:~/playground/morse-project/main.org::Cleanest Files with Predictors:][Cleanest]]
#+begin_src R :results file graphics :file img/cw176_norm.png
tuneR::readWave("../data/cw176.wav") %>%
  tuneR::normalize() %>%
  plot(main = "Original Waveform of `cw176`", xlim = c(0,1.25), col = "steelblue", ylab = "Amplitude")

text(0.1, -0.5, label = "E", col = "red", cex = 4, font = 4)
text(0.4, -0.5, label = "8", col = "red", cex = 4, font = 4)
text(0.75, -0.5, label = "G", col = "red", cex = 4, font = 4)
text(1.1, -0.5, label = "8", col = "red", cex = 4, font = 4)
#+end_src

*** [[file:~/playground/morse-project/main.org::Noisiest Files with Predictors:][Noisiest]]
#+begin_src R :results file graphics :file img/cw047_norm.png
tuneR::readWave("../data/cw047.wav") %>%
  tuneR::normalize() %>%
  plot(main = "Original Waveform of `cw047`", xlim = c(0,3.25), col = "steelblue", ylab = "Amplitude")
#+end_src

* Applying Seewave's Fourier Transform:
#+begin_src R :results file graphics :file img/cw047_raw_spectro.png
tuneR::readWave("../data/cw047.wav") %>%
  wav_remove_NAs() %>%
  tuneR::normalize() %>%
  spectro(flim = c(0.4, 0.8), tlim = c(0, 3.25), main = "Spectrogram of `cw047`")

# Label the CW:
text(x = 0.7, y = 0.5, labels = "E", col = "red", cex = 4, font = 4)
text(x = 1.5, y = 0.5, labels = "Z", col = "red", cex = 4, font = 4)
text(x = 2.5, y = 0.5, labels = "R", col = "red", cex = 4, font = 4)
#+end_src

* Applying the Filtering Script:
Clearly, the notch filter I devised using TuneR and Seewave is highly effective...

#+begin_src R :results file graphics :file img/cw047_filtered.png
tuneR::readWave("../out/anf/cw047_anf.wav") %>%
  tuneR::normalize() %>%
  plot(main = "Original Waveform of `cw047`", xlim = c(0,3.25), col = "steelblue", ylab = "Amplitude")
text(x = 0.7, y = -0.5, labels = "E", col = "red", cex = 4, font = 4)
text(x = 1.5, y = -0.5, labels = "Z", col = "red", cex = 4, font = 4)
text(x = 2.5, y = -0.5, labels = "R", col = "red", cex = 4, font = 4)
#+end_src

* Conclusion:
I used the libraries I originally selected to analyze the dataset I chose. I avoided the temptation to switch to other tools and stray from the objective, which at times took some strength. I found many more resources and tutorials for doing this sort of thing in Python, but these are better documented as far as how they actually work. This was fortunate, since I did have to do a fair bit of customization to get the graphics and their specific functions to work well for my purpose, which can be seen in [[file:~/playground/morse-project/R/project_functions.R][functions.R]]

I didn't get as far as developing the algorithms to decode the cleaned audio (by following the amplitude of the waveform). Once the audio is cleaned, the frequency is trivial, because the tone is the only high-amplitude component present. This matches up with real-world decoding on radio hardware.

The task of using image recognition to decode the fourier-transformed visualizations is much more interesting, and this seems to be what other researchers are doing, also. I'm not exactly sure why... Perhaps for very broad noise, or noise close to the signal's frequency, more advanced approaches are necessary?

Doing research with the tools I used takes longer than off-the-shelf solutions. But, the results I got are very repeatable and were well backed up at each step of the process, which was a strength. Also, anyone can download these utilities free of charge and verify my results.
